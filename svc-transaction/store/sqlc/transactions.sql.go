// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: transactions.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const cancelTransaction = `-- name: CancelTransaction :one
UPDATE core.transactions
SET 
    status = 'cancelled',
    updated_at = NOW(),
    metadata = COALESCE(metadata, '{}'::jsonb) || jsonb_build_object('cancellation_reason', $2)
WHERE id = $1 AND status = 'pending'
RETURNING id, status, updated_at
`

type CancelTransactionParams struct {
	ID               pgtype.UUID `json:"id"`
	JsonbBuildObject interface{} `json:"jsonb_build_object"`
}

type CancelTransactionRow struct {
	ID        pgtype.UUID           `json:"id"`
	Status    CoreTransactionStatus `json:"status"`
	UpdatedAt pgtype.Timestamptz    `json:"updated_at"`
}

func (q *Queries) CancelTransaction(ctx context.Context, arg CancelTransactionParams) (CancelTransactionRow, error) {
	row := q.db.QueryRow(ctx, cancelTransaction, arg.ID, arg.JsonbBuildObject)
	var i CancelTransactionRow
	err := row.Scan(&i.ID, &i.Status, &i.UpdatedAt)
	return i, err
}

const checkAccountBalance = `-- name: CheckAccountBalance :one
SELECT 
    id,
    account_number,
    account_name,
    balance,
    currency,
    status,
    CASE 
        WHEN $2::DECIMAL IS NULL THEN TRUE
        WHEN balance >= $2::DECIMAL THEN TRUE
        ELSE FALSE
    END AS sufficient_funds
FROM core.accounts
WHERE id = $1
`

type CheckAccountBalanceParams struct {
	ID      pgtype.UUID    `json:"id"`
	Column2 pgtype.Numeric `json:"column_2"`
}

type CheckAccountBalanceRow struct {
	ID              pgtype.UUID       `json:"id"`
	AccountNumber   string            `json:"account_number"`
	AccountName     string            `json:"account_name"`
	Balance         pgtype.Numeric    `json:"balance"`
	Currency        CoreCurrencyCode  `json:"currency"`
	Status          CoreAccountStatus `json:"status"`
	SufficientFunds bool              `json:"sufficient_funds"`
}

func (q *Queries) CheckAccountBalance(ctx context.Context, arg CheckAccountBalanceParams) (CheckAccountBalanceRow, error) {
	row := q.db.QueryRow(ctx, checkAccountBalance, arg.ID, arg.Column2)
	var i CheckAccountBalanceRow
	err := row.Scan(
		&i.ID,
		&i.AccountNumber,
		&i.AccountName,
		&i.Balance,
		&i.Currency,
		&i.Status,
		&i.SufficientFunds,
	)
	return i, err
}

const completeTransaction = `-- name: CompleteTransaction :one
UPDATE core.transactions
SET 
    status = 'completed',
    completed_at = NOW(),
    updated_at = NOW()
WHERE id = $1 AND status = 'pending'
RETURNING id, status, completed_at
`

type CompleteTransactionRow struct {
	ID          pgtype.UUID           `json:"id"`
	Status      CoreTransactionStatus `json:"status"`
	CompletedAt pgtype.Timestamptz    `json:"completed_at"`
}

func (q *Queries) CompleteTransaction(ctx context.Context, id pgtype.UUID) (CompleteTransactionRow, error) {
	row := q.db.QueryRow(ctx, completeTransaction, id)
	var i CompleteTransactionRow
	err := row.Scan(&i.ID, &i.Status, &i.CompletedAt)
	return i, err
}

const createBalanceHistoryRecord = `-- name: CreateBalanceHistoryRecord :one
INSERT INTO core.account_balance_history (
    account_id,
    transaction_id,
    old_balance,
    new_balance,
    balance_change,
    operation,
    created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, created_at
`

type CreateBalanceHistoryRecordParams struct {
	AccountID     pgtype.UUID    `json:"account_id"`
	TransactionID pgtype.UUID    `json:"transaction_id"`
	OldBalance    pgtype.Numeric `json:"old_balance"`
	NewBalance    pgtype.Numeric `json:"new_balance"`
	BalanceChange pgtype.Numeric `json:"balance_change"`
	Operation     string         `json:"operation"`
	CreatedBy     pgtype.Text    `json:"created_by"`
}

type CreateBalanceHistoryRecordRow struct {
	ID        pgtype.UUID        `json:"id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) CreateBalanceHistoryRecord(ctx context.Context, arg CreateBalanceHistoryRecordParams) (CreateBalanceHistoryRecordRow, error) {
	row := q.db.QueryRow(ctx, createBalanceHistoryRecord,
		arg.AccountID,
		arg.TransactionID,
		arg.OldBalance,
		arg.NewBalance,
		arg.BalanceChange,
		arg.Operation,
		arg.CreatedBy,
	)
	var i CreateBalanceHistoryRecordRow
	err := row.Scan(&i.ID, &i.CreatedAt)
	return i, err
}

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO core.transactions (
    account_id,
    transaction_type,
    amount,
    currency,
    description,
    reference_id,
    idempotency_key,
    metadata,
    status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, 'pending'
) RETURNING id, created_at
`

type CreateTransactionParams struct {
	AccountID       pgtype.UUID         `json:"account_id"`
	TransactionType CoreTransactionType `json:"transaction_type"`
	Amount          pgtype.Numeric      `json:"amount"`
	Currency        CoreCurrencyCode    `json:"currency"`
	Description     pgtype.Text         `json:"description"`
	ReferenceID     pgtype.Text         `json:"reference_id"`
	IdempotencyKey  pgtype.Text         `json:"idempotency_key"`
	Metadata        []byte              `json:"metadata"`
}

type CreateTransactionRow struct {
	ID        pgtype.UUID        `json:"id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (CreateTransactionRow, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.AccountID,
		arg.TransactionType,
		arg.Amount,
		arg.Currency,
		arg.Description,
		arg.ReferenceID,
		arg.IdempotencyKey,
		arg.Metadata,
	)
	var i CreateTransactionRow
	err := row.Scan(&i.ID, &i.CreatedAt)
	return i, err
}

const failTransaction = `-- name: FailTransaction :one
UPDATE core.transactions
SET 
    status = 'failed',
    updated_at = NOW(),
    metadata = COALESCE(metadata, '{}'::jsonb) || jsonb_build_object('failure_reason', $2)
WHERE id = $1 AND status = 'pending'
RETURNING id, status, updated_at
`

type FailTransactionParams struct {
	ID               pgtype.UUID `json:"id"`
	JsonbBuildObject interface{} `json:"jsonb_build_object"`
}

type FailTransactionRow struct {
	ID        pgtype.UUID           `json:"id"`
	Status    CoreTransactionStatus `json:"status"`
	UpdatedAt pgtype.Timestamptz    `json:"updated_at"`
}

func (q *Queries) FailTransaction(ctx context.Context, arg FailTransactionParams) (FailTransactionRow, error) {
	row := q.db.QueryRow(ctx, failTransaction, arg.ID, arg.JsonbBuildObject)
	var i FailTransactionRow
	err := row.Scan(&i.ID, &i.Status, &i.UpdatedAt)
	return i, err
}

const getAccountBalanceHistory = `-- name: GetAccountBalanceHistory :many
SELECT 
    id,
    account_id,
    transaction_id,
    old_balance,
    new_balance,
    balance_change,
    operation,
    created_at,
    created_by
FROM core.account_balance_history
WHERE account_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetAccountBalanceHistoryParams struct {
	AccountID pgtype.UUID `json:"account_id"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

func (q *Queries) GetAccountBalanceHistory(ctx context.Context, arg GetAccountBalanceHistoryParams) ([]CoreAccountBalanceHistory, error) {
	rows, err := q.db.Query(ctx, getAccountBalanceHistory, arg.AccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CoreAccountBalanceHistory{}
	for rows.Next() {
		var i CoreAccountBalanceHistory
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.TransactionID,
			&i.OldBalance,
			&i.NewBalance,
			&i.BalanceChange,
			&i.Operation,
			&i.CreatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccountByAccountNumber = `-- name: GetAccountByAccountNumber :one
SELECT 
    id,
    account_number,
    account_name,
    balance,
    currency,
    status,
    created_at,
    updated_at,
    version
FROM core.accounts
WHERE account_number = $1
`

func (q *Queries) GetAccountByAccountNumber(ctx context.Context, accountNumber string) (CoreAccount, error) {
	row := q.db.QueryRow(ctx, getAccountByAccountNumber, accountNumber)
	var i CoreAccount
	err := row.Scan(
		&i.ID,
		&i.AccountNumber,
		&i.AccountName,
		&i.Balance,
		&i.Currency,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
	)
	return i, err
}

const getAccountByID = `-- name: GetAccountByID :one

SELECT 
    id,
    account_number,
    account_name,
    balance,
    currency,
    status,
    created_at,
    updated_at,
    version
FROM core.accounts
WHERE id = $1
`

// Account-related queries for transaction service
func (q *Queries) GetAccountByID(ctx context.Context, id pgtype.UUID) (CoreAccount, error) {
	row := q.db.QueryRow(ctx, getAccountByID, id)
	var i CoreAccount
	err := row.Scan(
		&i.ID,
		&i.AccountNumber,
		&i.AccountName,
		&i.Balance,
		&i.Currency,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
	)
	return i, err
}

const getBalanceHistoryByDateRange = `-- name: GetBalanceHistoryByDateRange :many
SELECT 
    id,
    account_id,
    transaction_id,
    old_balance,
    new_balance,
    balance_change,
    operation,
    created_at,
    created_by
FROM core.account_balance_history
WHERE account_id = $1
    AND created_at BETWEEN $2 AND $3
ORDER BY created_at DESC
LIMIT $4 OFFSET $5
`

type GetBalanceHistoryByDateRangeParams struct {
	AccountID   pgtype.UUID        `json:"account_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
	Limit       int32              `json:"limit"`
	Offset      int32              `json:"offset"`
}

func (q *Queries) GetBalanceHistoryByDateRange(ctx context.Context, arg GetBalanceHistoryByDateRangeParams) ([]CoreAccountBalanceHistory, error) {
	rows, err := q.db.Query(ctx, getBalanceHistoryByDateRange,
		arg.AccountID,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CoreAccountBalanceHistory{}
	for rows.Next() {
		var i CoreAccountBalanceHistory
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.TransactionID,
			&i.OldBalance,
			&i.NewBalance,
			&i.BalanceChange,
			&i.Operation,
			&i.CreatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBalanceHistoryByTransaction = `-- name: GetBalanceHistoryByTransaction :many
SELECT 
    id,
    account_id,
    transaction_id,
    old_balance,
    new_balance,
    balance_change,
    operation,
    created_at,
    created_by
FROM core.account_balance_history
WHERE transaction_id = $1
ORDER BY created_at ASC
`

func (q *Queries) GetBalanceHistoryByTransaction(ctx context.Context, transactionID pgtype.UUID) ([]CoreAccountBalanceHistory, error) {
	rows, err := q.db.Query(ctx, getBalanceHistoryByTransaction, transactionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CoreAccountBalanceHistory{}
	for rows.Next() {
		var i CoreAccountBalanceHistory
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.TransactionID,
			&i.OldBalance,
			&i.NewBalance,
			&i.BalanceChange,
			&i.Operation,
			&i.CreatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingTransactions = `-- name: GetPendingTransactions :many
SELECT 
    id,
    account_id,
    transaction_type,
    amount,
    currency,
    description,
    reference_id,
    idempotency_key,
    status,
    created_at,
    metadata
FROM core.transactions
WHERE status = 'pending'
    AND created_at < NOW() - INTERVAL '5 minutes'
ORDER BY created_at ASC
LIMIT $1
`

type GetPendingTransactionsRow struct {
	ID              pgtype.UUID           `json:"id"`
	AccountID       pgtype.UUID           `json:"account_id"`
	TransactionType CoreTransactionType   `json:"transaction_type"`
	Amount          pgtype.Numeric        `json:"amount"`
	Currency        CoreCurrencyCode      `json:"currency"`
	Description     pgtype.Text           `json:"description"`
	ReferenceID     pgtype.Text           `json:"reference_id"`
	IdempotencyKey  pgtype.Text           `json:"idempotency_key"`
	Status          CoreTransactionStatus `json:"status"`
	CreatedAt       pgtype.Timestamptz    `json:"created_at"`
	Metadata        []byte                `json:"metadata"`
}

func (q *Queries) GetPendingTransactions(ctx context.Context, limit int32) ([]GetPendingTransactionsRow, error) {
	rows, err := q.db.Query(ctx, getPendingTransactions, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPendingTransactionsRow{}
	for rows.Next() {
		var i GetPendingTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.TransactionType,
			&i.Amount,
			&i.Currency,
			&i.Description,
			&i.ReferenceID,
			&i.IdempotencyKey,
			&i.Status,
			&i.CreatedAt,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentTransactionsByAccount = `-- name: GetRecentTransactionsByAccount :many
SELECT 
    id,
    account_id,
    transaction_type,
    amount,
    currency,
    description,
    reference_id,
    status,
    created_at,
    completed_at
FROM core.transactions
WHERE account_id = $1
    AND created_at >= NOW() - INTERVAL '30 days'
ORDER BY created_at DESC
LIMIT $2
`

type GetRecentTransactionsByAccountParams struct {
	AccountID pgtype.UUID `json:"account_id"`
	Limit     int32       `json:"limit"`
}

type GetRecentTransactionsByAccountRow struct {
	ID              pgtype.UUID           `json:"id"`
	AccountID       pgtype.UUID           `json:"account_id"`
	TransactionType CoreTransactionType   `json:"transaction_type"`
	Amount          pgtype.Numeric        `json:"amount"`
	Currency        CoreCurrencyCode      `json:"currency"`
	Description     pgtype.Text           `json:"description"`
	ReferenceID     pgtype.Text           `json:"reference_id"`
	Status          CoreTransactionStatus `json:"status"`
	CreatedAt       pgtype.Timestamptz    `json:"created_at"`
	CompletedAt     pgtype.Timestamptz    `json:"completed_at"`
}

func (q *Queries) GetRecentTransactionsByAccount(ctx context.Context, arg GetRecentTransactionsByAccountParams) ([]GetRecentTransactionsByAccountRow, error) {
	rows, err := q.db.Query(ctx, getRecentTransactionsByAccount, arg.AccountID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentTransactionsByAccountRow{}
	for rows.Next() {
		var i GetRecentTransactionsByAccountRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.TransactionType,
			&i.Amount,
			&i.Currency,
			&i.Description,
			&i.ReferenceID,
			&i.Status,
			&i.CreatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionByID = `-- name: GetTransactionByID :one
SELECT 
    id,
    account_id,
    transaction_type,
    amount,
    currency,
    description,
    reference_id,
    idempotency_key,
    status,
    created_at,
    updated_at,
    completed_at,
    metadata
FROM core.transactions
WHERE id = $1
`

type GetTransactionByIDRow struct {
	ID              pgtype.UUID           `json:"id"`
	AccountID       pgtype.UUID           `json:"account_id"`
	TransactionType CoreTransactionType   `json:"transaction_type"`
	Amount          pgtype.Numeric        `json:"amount"`
	Currency        CoreCurrencyCode      `json:"currency"`
	Description     pgtype.Text           `json:"description"`
	ReferenceID     pgtype.Text           `json:"reference_id"`
	IdempotencyKey  pgtype.Text           `json:"idempotency_key"`
	Status          CoreTransactionStatus `json:"status"`
	CreatedAt       pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz    `json:"updated_at"`
	CompletedAt     pgtype.Timestamptz    `json:"completed_at"`
	Metadata        []byte                `json:"metadata"`
}

func (q *Queries) GetTransactionByID(ctx context.Context, id pgtype.UUID) (GetTransactionByIDRow, error) {
	row := q.db.QueryRow(ctx, getTransactionByID, id)
	var i GetTransactionByIDRow
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.TransactionType,
		&i.Amount,
		&i.Currency,
		&i.Description,
		&i.ReferenceID,
		&i.IdempotencyKey,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.Metadata,
	)
	return i, err
}

const getTransactionByIdempotencyKey = `-- name: GetTransactionByIdempotencyKey :one
SELECT 
    id,
    account_id,
    transaction_type,
    amount,
    currency,
    description,
    reference_id,
    idempotency_key,
    status,
    created_at,
    updated_at,
    completed_at,
    metadata
FROM core.transactions
WHERE idempotency_key = $1
`

type GetTransactionByIdempotencyKeyRow struct {
	ID              pgtype.UUID           `json:"id"`
	AccountID       pgtype.UUID           `json:"account_id"`
	TransactionType CoreTransactionType   `json:"transaction_type"`
	Amount          pgtype.Numeric        `json:"amount"`
	Currency        CoreCurrencyCode      `json:"currency"`
	Description     pgtype.Text           `json:"description"`
	ReferenceID     pgtype.Text           `json:"reference_id"`
	IdempotencyKey  pgtype.Text           `json:"idempotency_key"`
	Status          CoreTransactionStatus `json:"status"`
	CreatedAt       pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz    `json:"updated_at"`
	CompletedAt     pgtype.Timestamptz    `json:"completed_at"`
	Metadata        []byte                `json:"metadata"`
}

func (q *Queries) GetTransactionByIdempotencyKey(ctx context.Context, idempotencyKey pgtype.Text) (GetTransactionByIdempotencyKeyRow, error) {
	row := q.db.QueryRow(ctx, getTransactionByIdempotencyKey, idempotencyKey)
	var i GetTransactionByIdempotencyKeyRow
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.TransactionType,
		&i.Amount,
		&i.Currency,
		&i.Description,
		&i.ReferenceID,
		&i.IdempotencyKey,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.Metadata,
	)
	return i, err
}

const getTransactionSummaryByAccount = `-- name: GetTransactionSummaryByAccount :one
SELECT 
    account_id,
    COUNT(*) AS total_transactions,
    COUNT(CASE WHEN status = 'completed' THEN 1 END) AS completed_transactions,
    COUNT(CASE WHEN status = 'pending' THEN 1 END) AS pending_transactions,
    COUNT(CASE WHEN status = 'failed' THEN 1 END) AS failed_transactions,
    COALESCE(SUM(CASE WHEN transaction_type = 'debit' AND status = 'completed' THEN amount ELSE 0 END), 0) AS total_debits,
    COALESCE(SUM(CASE WHEN transaction_type = 'credit' AND status = 'completed' THEN amount ELSE 0 END), 0) AS total_credits
FROM core.transactions
WHERE account_id = $1
`

type GetTransactionSummaryByAccountRow struct {
	AccountID             pgtype.UUID `json:"account_id"`
	TotalTransactions     int64       `json:"total_transactions"`
	CompletedTransactions int64       `json:"completed_transactions"`
	PendingTransactions   int64       `json:"pending_transactions"`
	FailedTransactions    int64       `json:"failed_transactions"`
	TotalDebits           interface{} `json:"total_debits"`
	TotalCredits          interface{} `json:"total_credits"`
}

func (q *Queries) GetTransactionSummaryByAccount(ctx context.Context, accountID pgtype.UUID) (GetTransactionSummaryByAccountRow, error) {
	row := q.db.QueryRow(ctx, getTransactionSummaryByAccount, accountID)
	var i GetTransactionSummaryByAccountRow
	err := row.Scan(
		&i.AccountID,
		&i.TotalTransactions,
		&i.CompletedTransactions,
		&i.PendingTransactions,
		&i.FailedTransactions,
		&i.TotalDebits,
		&i.TotalCredits,
	)
	return i, err
}

const getTransactionsByAccount = `-- name: GetTransactionsByAccount :many
SELECT 
    id,
    account_id,
    transaction_type,
    amount,
    currency,
    description,
    reference_id,
    status,
    created_at,
    completed_at
FROM core.transactions
WHERE account_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetTransactionsByAccountParams struct {
	AccountID pgtype.UUID `json:"account_id"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

type GetTransactionsByAccountRow struct {
	ID              pgtype.UUID           `json:"id"`
	AccountID       pgtype.UUID           `json:"account_id"`
	TransactionType CoreTransactionType   `json:"transaction_type"`
	Amount          pgtype.Numeric        `json:"amount"`
	Currency        CoreCurrencyCode      `json:"currency"`
	Description     pgtype.Text           `json:"description"`
	ReferenceID     pgtype.Text           `json:"reference_id"`
	Status          CoreTransactionStatus `json:"status"`
	CreatedAt       pgtype.Timestamptz    `json:"created_at"`
	CompletedAt     pgtype.Timestamptz    `json:"completed_at"`
}

func (q *Queries) GetTransactionsByAccount(ctx context.Context, arg GetTransactionsByAccountParams) ([]GetTransactionsByAccountRow, error) {
	rows, err := q.db.Query(ctx, getTransactionsByAccount, arg.AccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTransactionsByAccountRow{}
	for rows.Next() {
		var i GetTransactionsByAccountRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.TransactionType,
			&i.Amount,
			&i.Currency,
			&i.Description,
			&i.ReferenceID,
			&i.Status,
			&i.CreatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByAccountAndType = `-- name: GetTransactionsByAccountAndType :many
SELECT 
    id,
    account_id,
    transaction_type,
    amount,
    currency,
    description,
    reference_id,
    status,
    created_at,
    completed_at
FROM core.transactions
WHERE account_id = $1 AND transaction_type = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type GetTransactionsByAccountAndTypeParams struct {
	AccountID       pgtype.UUID         `json:"account_id"`
	TransactionType CoreTransactionType `json:"transaction_type"`
	Limit           int32               `json:"limit"`
	Offset          int32               `json:"offset"`
}

type GetTransactionsByAccountAndTypeRow struct {
	ID              pgtype.UUID           `json:"id"`
	AccountID       pgtype.UUID           `json:"account_id"`
	TransactionType CoreTransactionType   `json:"transaction_type"`
	Amount          pgtype.Numeric        `json:"amount"`
	Currency        CoreCurrencyCode      `json:"currency"`
	Description     pgtype.Text           `json:"description"`
	ReferenceID     pgtype.Text           `json:"reference_id"`
	Status          CoreTransactionStatus `json:"status"`
	CreatedAt       pgtype.Timestamptz    `json:"created_at"`
	CompletedAt     pgtype.Timestamptz    `json:"completed_at"`
}

func (q *Queries) GetTransactionsByAccountAndType(ctx context.Context, arg GetTransactionsByAccountAndTypeParams) ([]GetTransactionsByAccountAndTypeRow, error) {
	rows, err := q.db.Query(ctx, getTransactionsByAccountAndType,
		arg.AccountID,
		arg.TransactionType,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTransactionsByAccountAndTypeRow{}
	for rows.Next() {
		var i GetTransactionsByAccountAndTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.TransactionType,
			&i.Amount,
			&i.Currency,
			&i.Description,
			&i.ReferenceID,
			&i.Status,
			&i.CreatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByDateRange = `-- name: GetTransactionsByDateRange :many
SELECT 
    id,
    account_id,
    transaction_type,
    amount,
    currency,
    description,
    reference_id,
    status,
    created_at,
    completed_at
FROM core.transactions
WHERE created_at BETWEEN $1 AND $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type GetTransactionsByDateRangeParams struct {
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
	Limit       int32              `json:"limit"`
	Offset      int32              `json:"offset"`
}

type GetTransactionsByDateRangeRow struct {
	ID              pgtype.UUID           `json:"id"`
	AccountID       pgtype.UUID           `json:"account_id"`
	TransactionType CoreTransactionType   `json:"transaction_type"`
	Amount          pgtype.Numeric        `json:"amount"`
	Currency        CoreCurrencyCode      `json:"currency"`
	Description     pgtype.Text           `json:"description"`
	ReferenceID     pgtype.Text           `json:"reference_id"`
	Status          CoreTransactionStatus `json:"status"`
	CreatedAt       pgtype.Timestamptz    `json:"created_at"`
	CompletedAt     pgtype.Timestamptz    `json:"completed_at"`
}

func (q *Queries) GetTransactionsByDateRange(ctx context.Context, arg GetTransactionsByDateRangeParams) ([]GetTransactionsByDateRangeRow, error) {
	rows, err := q.db.Query(ctx, getTransactionsByDateRange,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTransactionsByDateRangeRow{}
	for rows.Next() {
		var i GetTransactionsByDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.TransactionType,
			&i.Amount,
			&i.Currency,
			&i.Description,
			&i.ReferenceID,
			&i.Status,
			&i.CreatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByReference = `-- name: GetTransactionsByReference :many
SELECT 
    id,
    account_id,
    transaction_type,
    amount,
    currency,
    description,
    reference_id,
    status,
    created_at,
    completed_at
FROM core.transactions
WHERE reference_id = $1
ORDER BY created_at ASC
`

type GetTransactionsByReferenceRow struct {
	ID              pgtype.UUID           `json:"id"`
	AccountID       pgtype.UUID           `json:"account_id"`
	TransactionType CoreTransactionType   `json:"transaction_type"`
	Amount          pgtype.Numeric        `json:"amount"`
	Currency        CoreCurrencyCode      `json:"currency"`
	Description     pgtype.Text           `json:"description"`
	ReferenceID     pgtype.Text           `json:"reference_id"`
	Status          CoreTransactionStatus `json:"status"`
	CreatedAt       pgtype.Timestamptz    `json:"created_at"`
	CompletedAt     pgtype.Timestamptz    `json:"completed_at"`
}

func (q *Queries) GetTransactionsByReference(ctx context.Context, referenceID pgtype.Text) ([]GetTransactionsByReferenceRow, error) {
	rows, err := q.db.Query(ctx, getTransactionsByReference, referenceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTransactionsByReferenceRow{}
	for rows.Next() {
		var i GetTransactionsByReferenceRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.TransactionType,
			&i.Amount,
			&i.Currency,
			&i.Description,
			&i.ReferenceID,
			&i.Status,
			&i.CreatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByStatus = `-- name: GetTransactionsByStatus :many
SELECT 
    id,
    account_id,
    transaction_type,
    amount,
    currency,
    description,
    reference_id,
    status,
    created_at,
    completed_at
FROM core.transactions
WHERE status = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetTransactionsByStatusParams struct {
	Status CoreTransactionStatus `json:"status"`
	Limit  int32                 `json:"limit"`
	Offset int32                 `json:"offset"`
}

type GetTransactionsByStatusRow struct {
	ID              pgtype.UUID           `json:"id"`
	AccountID       pgtype.UUID           `json:"account_id"`
	TransactionType CoreTransactionType   `json:"transaction_type"`
	Amount          pgtype.Numeric        `json:"amount"`
	Currency        CoreCurrencyCode      `json:"currency"`
	Description     pgtype.Text           `json:"description"`
	ReferenceID     pgtype.Text           `json:"reference_id"`
	Status          CoreTransactionStatus `json:"status"`
	CreatedAt       pgtype.Timestamptz    `json:"created_at"`
	CompletedAt     pgtype.Timestamptz    `json:"completed_at"`
}

func (q *Queries) GetTransactionsByStatus(ctx context.Context, arg GetTransactionsByStatusParams) ([]GetTransactionsByStatusRow, error) {
	rows, err := q.db.Query(ctx, getTransactionsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTransactionsByStatusRow{}
	for rows.Next() {
		var i GetTransactionsByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.TransactionType,
			&i.Amount,
			&i.Currency,
			&i.Description,
			&i.ReferenceID,
			&i.Status,
			&i.CreatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTransactionMetadata = `-- name: UpdateTransactionMetadata :one
UPDATE core.transactions
SET 
    metadata = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, metadata, updated_at
`

type UpdateTransactionMetadataParams struct {
	ID       pgtype.UUID `json:"id"`
	Metadata []byte      `json:"metadata"`
}

type UpdateTransactionMetadataRow struct {
	ID        pgtype.UUID        `json:"id"`
	Metadata  []byte             `json:"metadata"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateTransactionMetadata(ctx context.Context, arg UpdateTransactionMetadataParams) (UpdateTransactionMetadataRow, error) {
	row := q.db.QueryRow(ctx, updateTransactionMetadata, arg.ID, arg.Metadata)
	var i UpdateTransactionMetadataRow
	err := row.Scan(&i.ID, &i.Metadata, &i.UpdatedAt)
	return i, err
}

const updateTransactionStatus = `-- name: UpdateTransactionStatus :one
UPDATE core.transactions
SET 
    status = $2,
    updated_at = NOW(),
    completed_at = CASE WHEN $2 = 'completed' THEN NOW() ELSE completed_at END
WHERE id = $1
RETURNING id, status, updated_at, completed_at
`

type UpdateTransactionStatusParams struct {
	ID     pgtype.UUID           `json:"id"`
	Status CoreTransactionStatus `json:"status"`
}

type UpdateTransactionStatusRow struct {
	ID          pgtype.UUID           `json:"id"`
	Status      CoreTransactionStatus `json:"status"`
	UpdatedAt   pgtype.Timestamptz    `json:"updated_at"`
	CompletedAt pgtype.Timestamptz    `json:"completed_at"`
}

func (q *Queries) UpdateTransactionStatus(ctx context.Context, arg UpdateTransactionStatusParams) (UpdateTransactionStatusRow, error) {
	row := q.db.QueryRow(ctx, updateTransactionStatus, arg.ID, arg.Status)
	var i UpdateTransactionStatusRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}
