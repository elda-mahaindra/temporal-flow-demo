// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: compensation.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCompensationAudit = `-- name: CreateCompensationAudit :one
INSERT INTO core.compensation_audit_trail (
    workflow_id,
    run_id,
    transfer_id,
    original_transaction_id,
    compensation_reason,
    compensation_type,
    compensation_status,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, workflow_id, run_id, transfer_id, original_transaction_id, compensation_transaction_id, compensation_reason, compensation_type, compensation_status, compensation_attempts, created_at, updated_at, completed_at, failure_reason, timeout_duration_ms, metadata
`

type CreateCompensationAuditParams struct {
	WorkflowID            string                 `json:"workflow_id"`
	RunID                 string                 `json:"run_id"`
	TransferID            pgtype.Text            `json:"transfer_id"`
	OriginalTransactionID pgtype.UUID            `json:"original_transaction_id"`
	CompensationReason    string                 `json:"compensation_reason"`
	CompensationType      CoreCompensationType   `json:"compensation_type"`
	CompensationStatus    CoreCompensationStatus `json:"compensation_status"`
	Metadata              []byte                 `json:"metadata"`
}

func (q *Queries) CreateCompensationAudit(ctx context.Context, arg CreateCompensationAuditParams) (CoreCompensationAuditTrail, error) {
	row := q.db.QueryRow(ctx, createCompensationAudit,
		arg.WorkflowID,
		arg.RunID,
		arg.TransferID,
		arg.OriginalTransactionID,
		arg.CompensationReason,
		arg.CompensationType,
		arg.CompensationStatus,
		arg.Metadata,
	)
	var i CoreCompensationAuditTrail
	err := row.Scan(
		&i.ID,
		&i.WorkflowID,
		&i.RunID,
		&i.TransferID,
		&i.OriginalTransactionID,
		&i.CompensationTransactionID,
		&i.CompensationReason,
		&i.CompensationType,
		&i.CompensationStatus,
		&i.CompensationAttempts,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.FailureReason,
		&i.TimeoutDurationMs,
		&i.Metadata,
	)
	return i, err
}

const getCompensationAuditByTransferID = `-- name: GetCompensationAuditByTransferID :many
SELECT id, workflow_id, run_id, transfer_id, original_transaction_id, compensation_transaction_id, compensation_reason, compensation_type, compensation_status, compensation_attempts, created_at, updated_at, completed_at, failure_reason, timeout_duration_ms, metadata FROM core.compensation_audit_trail 
WHERE transfer_id = $1 
ORDER BY created_at DESC
`

func (q *Queries) GetCompensationAuditByTransferID(ctx context.Context, transferID pgtype.Text) ([]CoreCompensationAuditTrail, error) {
	rows, err := q.db.Query(ctx, getCompensationAuditByTransferID, transferID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CoreCompensationAuditTrail{}
	for rows.Next() {
		var i CoreCompensationAuditTrail
		if err := rows.Scan(
			&i.ID,
			&i.WorkflowID,
			&i.RunID,
			&i.TransferID,
			&i.OriginalTransactionID,
			&i.CompensationTransactionID,
			&i.CompensationReason,
			&i.CompensationType,
			&i.CompensationStatus,
			&i.CompensationAttempts,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.FailureReason,
			&i.TimeoutDurationMs,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompensationAuditByWorkflowID = `-- name: GetCompensationAuditByWorkflowID :many
SELECT id, workflow_id, run_id, transfer_id, original_transaction_id, compensation_transaction_id, compensation_reason, compensation_type, compensation_status, compensation_attempts, created_at, updated_at, completed_at, failure_reason, timeout_duration_ms, metadata FROM core.compensation_audit_trail 
WHERE workflow_id = $1 
ORDER BY created_at DESC
`

func (q *Queries) GetCompensationAuditByWorkflowID(ctx context.Context, workflowID string) ([]CoreCompensationAuditTrail, error) {
	rows, err := q.db.Query(ctx, getCompensationAuditByWorkflowID, workflowID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CoreCompensationAuditTrail{}
	for rows.Next() {
		var i CoreCompensationAuditTrail
		if err := rows.Scan(
			&i.ID,
			&i.WorkflowID,
			&i.RunID,
			&i.TransferID,
			&i.OriginalTransactionID,
			&i.CompensationTransactionID,
			&i.CompensationReason,
			&i.CompensationType,
			&i.CompensationStatus,
			&i.CompensationAttempts,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.FailureReason,
			&i.TimeoutDurationMs,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompensationStats = `-- name: GetCompensationStats :one
SELECT 
    COUNT(*) as total_compensations,
    COUNT(*) FILTER (WHERE compensation_status = 'completed') as completed_compensations,
    COUNT(*) FILTER (WHERE compensation_status = 'failed') as failed_compensations,
    COUNT(*) FILTER (WHERE compensation_status = 'timeout') as timeout_compensations,
    COUNT(*) FILTER (WHERE compensation_status = 'manual_required') as manual_compensations,
    COUNT(*) FILTER (WHERE compensation_status = 'pending') as pending_compensations,
    AVG(compensation_attempts) as avg_attempts
FROM core.compensation_audit_trail
WHERE created_at >= NOW() - INTERVAL '24 hours'
`

type GetCompensationStatsRow struct {
	TotalCompensations     int64   `json:"total_compensations"`
	CompletedCompensations int64   `json:"completed_compensations"`
	FailedCompensations    int64   `json:"failed_compensations"`
	TimeoutCompensations   int64   `json:"timeout_compensations"`
	ManualCompensations    int64   `json:"manual_compensations"`
	PendingCompensations   int64   `json:"pending_compensations"`
	AvgAttempts            float64 `json:"avg_attempts"`
}

func (q *Queries) GetCompensationStats(ctx context.Context) (GetCompensationStatsRow, error) {
	row := q.db.QueryRow(ctx, getCompensationStats)
	var i GetCompensationStatsRow
	err := row.Scan(
		&i.TotalCompensations,
		&i.CompletedCompensations,
		&i.FailedCompensations,
		&i.TimeoutCompensations,
		&i.ManualCompensations,
		&i.PendingCompensations,
		&i.AvgAttempts,
	)
	return i, err
}

const getFailedCompensationsByTimeoutDuration = `-- name: GetFailedCompensationsByTimeoutDuration :many
SELECT 
    workflow_id,
    transfer_id,
    compensation_reason,
    timeout_duration_ms,
    compensation_attempts,
    created_at,
    failure_reason
FROM core.compensation_audit_trail 
WHERE compensation_status = 'timeout' 
AND timeout_duration_ms > $1
ORDER BY timeout_duration_ms DESC, created_at DESC
LIMIT $2
`

type GetFailedCompensationsByTimeoutDurationParams struct {
	TimeoutDurationMs pgtype.Int4 `json:"timeout_duration_ms"`
	Limit             int32       `json:"limit"`
}

type GetFailedCompensationsByTimeoutDurationRow struct {
	WorkflowID           string             `json:"workflow_id"`
	TransferID           pgtype.Text        `json:"transfer_id"`
	CompensationReason   string             `json:"compensation_reason"`
	TimeoutDurationMs    pgtype.Int4        `json:"timeout_duration_ms"`
	CompensationAttempts int32              `json:"compensation_attempts"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	FailureReason        pgtype.Text        `json:"failure_reason"`
}

func (q *Queries) GetFailedCompensationsByTimeoutDuration(ctx context.Context, arg GetFailedCompensationsByTimeoutDurationParams) ([]GetFailedCompensationsByTimeoutDurationRow, error) {
	rows, err := q.db.Query(ctx, getFailedCompensationsByTimeoutDuration, arg.TimeoutDurationMs, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFailedCompensationsByTimeoutDurationRow{}
	for rows.Next() {
		var i GetFailedCompensationsByTimeoutDurationRow
		if err := rows.Scan(
			&i.WorkflowID,
			&i.TransferID,
			&i.CompensationReason,
			&i.TimeoutDurationMs,
			&i.CompensationAttempts,
			&i.CreatedAt,
			&i.FailureReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingCompensations = `-- name: GetPendingCompensations :many
SELECT id, workflow_id, run_id, transfer_id, original_transaction_id, compensation_transaction_id, compensation_reason, compensation_type, compensation_status, compensation_attempts, created_at, updated_at, completed_at, failure_reason, timeout_duration_ms, metadata FROM core.compensation_audit_trail 
WHERE compensation_status = 'pending' 
AND created_at < NOW() - INTERVAL '5 minutes'
ORDER BY created_at ASC
LIMIT $1
`

func (q *Queries) GetPendingCompensations(ctx context.Context, limit int32) ([]CoreCompensationAuditTrail, error) {
	rows, err := q.db.Query(ctx, getPendingCompensations, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CoreCompensationAuditTrail{}
	for rows.Next() {
		var i CoreCompensationAuditTrail
		if err := rows.Scan(
			&i.ID,
			&i.WorkflowID,
			&i.RunID,
			&i.TransferID,
			&i.OriginalTransactionID,
			&i.CompensationTransactionID,
			&i.CompensationReason,
			&i.CompensationType,
			&i.CompensationStatus,
			&i.CompensationAttempts,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.FailureReason,
			&i.TimeoutDurationMs,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCompensationAudit = `-- name: UpdateCompensationAudit :one
UPDATE core.compensation_audit_trail 
SET 
    compensation_status = $2,
    compensation_transaction_id = $3,
    compensation_attempts = compensation_attempts + 1,
    completed_at = CASE WHEN $2 IN ('completed', 'failed', 'timeout', 'manual_required') THEN NOW() ELSE completed_at END,
    failure_reason = $4,
    timeout_duration_ms = $5,
    updated_at = NOW()
WHERE workflow_id = $1
RETURNING id, workflow_id, run_id, transfer_id, original_transaction_id, compensation_transaction_id, compensation_reason, compensation_type, compensation_status, compensation_attempts, created_at, updated_at, completed_at, failure_reason, timeout_duration_ms, metadata
`

type UpdateCompensationAuditParams struct {
	WorkflowID                string                 `json:"workflow_id"`
	CompensationStatus        CoreCompensationStatus `json:"compensation_status"`
	CompensationTransactionID pgtype.UUID            `json:"compensation_transaction_id"`
	FailureReason             pgtype.Text            `json:"failure_reason"`
	TimeoutDurationMs         pgtype.Int4            `json:"timeout_duration_ms"`
}

func (q *Queries) UpdateCompensationAudit(ctx context.Context, arg UpdateCompensationAuditParams) (CoreCompensationAuditTrail, error) {
	row := q.db.QueryRow(ctx, updateCompensationAudit,
		arg.WorkflowID,
		arg.CompensationStatus,
		arg.CompensationTransactionID,
		arg.FailureReason,
		arg.TimeoutDurationMs,
	)
	var i CoreCompensationAuditTrail
	err := row.Scan(
		&i.ID,
		&i.WorkflowID,
		&i.RunID,
		&i.TransferID,
		&i.OriginalTransactionID,
		&i.CompensationTransactionID,
		&i.CompensationReason,
		&i.CompensationType,
		&i.CompensationStatus,
		&i.CompensationAttempts,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.FailureReason,
		&i.TimeoutDurationMs,
		&i.Metadata,
	)
	return i, err
}
