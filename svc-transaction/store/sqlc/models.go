// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package sqlc

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type CoreAccountStatus string

const (
	CoreAccountStatusActive    CoreAccountStatus = "active"
	CoreAccountStatusInactive  CoreAccountStatus = "inactive"
	CoreAccountStatusSuspended CoreAccountStatus = "suspended"
	CoreAccountStatusClosed    CoreAccountStatus = "closed"
)

func (e *CoreAccountStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CoreAccountStatus(s)
	case string:
		*e = CoreAccountStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for CoreAccountStatus: %T", src)
	}
	return nil
}

type NullCoreAccountStatus struct {
	CoreAccountStatus CoreAccountStatus `json:"core_account_status"`
	Valid             bool              `json:"valid"` // Valid is true if CoreAccountStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCoreAccountStatus) Scan(value interface{}) error {
	if value == nil {
		ns.CoreAccountStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CoreAccountStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCoreAccountStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CoreAccountStatus), nil
}

type CoreCompensationStatus string

const (
	CoreCompensationStatusPending        CoreCompensationStatus = "pending"
	CoreCompensationStatusCompleted      CoreCompensationStatus = "completed"
	CoreCompensationStatusFailed         CoreCompensationStatus = "failed"
	CoreCompensationStatusTimeout        CoreCompensationStatus = "timeout"
	CoreCompensationStatusManualRequired CoreCompensationStatus = "manual_required"
)

func (e *CoreCompensationStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CoreCompensationStatus(s)
	case string:
		*e = CoreCompensationStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for CoreCompensationStatus: %T", src)
	}
	return nil
}

type NullCoreCompensationStatus struct {
	CoreCompensationStatus CoreCompensationStatus `json:"core_compensation_status"`
	Valid                  bool                   `json:"valid"` // Valid is true if CoreCompensationStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCoreCompensationStatus) Scan(value interface{}) error {
	if value == nil {
		ns.CoreCompensationStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CoreCompensationStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCoreCompensationStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CoreCompensationStatus), nil
}

type CoreCompensationType string

const (
	CoreCompensationTypeDebitReversal    CoreCompensationType = "debit_reversal"
	CoreCompensationTypeCreditReversal   CoreCompensationType = "credit_reversal"
	CoreCompensationTypeManualAdjustment CoreCompensationType = "manual_adjustment"
)

func (e *CoreCompensationType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CoreCompensationType(s)
	case string:
		*e = CoreCompensationType(s)
	default:
		return fmt.Errorf("unsupported scan type for CoreCompensationType: %T", src)
	}
	return nil
}

type NullCoreCompensationType struct {
	CoreCompensationType CoreCompensationType `json:"core_compensation_type"`
	Valid                bool                 `json:"valid"` // Valid is true if CoreCompensationType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCoreCompensationType) Scan(value interface{}) error {
	if value == nil {
		ns.CoreCompensationType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CoreCompensationType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCoreCompensationType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CoreCompensationType), nil
}

type CoreCurrencyCode string

const (
	CoreCurrencyCodeUSD CoreCurrencyCode = "USD"
	CoreCurrencyCodeEUR CoreCurrencyCode = "EUR"
	CoreCurrencyCodeGBP CoreCurrencyCode = "GBP"
	CoreCurrencyCodeJPY CoreCurrencyCode = "JPY"
	CoreCurrencyCodeCAD CoreCurrencyCode = "CAD"
	CoreCurrencyCodeAUD CoreCurrencyCode = "AUD"
	CoreCurrencyCodeCHF CoreCurrencyCode = "CHF"
	CoreCurrencyCodeCNY CoreCurrencyCode = "CNY"
	CoreCurrencyCodeSGD CoreCurrencyCode = "SGD"
	CoreCurrencyCodeHKD CoreCurrencyCode = "HKD"
)

func (e *CoreCurrencyCode) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CoreCurrencyCode(s)
	case string:
		*e = CoreCurrencyCode(s)
	default:
		return fmt.Errorf("unsupported scan type for CoreCurrencyCode: %T", src)
	}
	return nil
}

type NullCoreCurrencyCode struct {
	CoreCurrencyCode CoreCurrencyCode `json:"core_currency_code"`
	Valid            bool             `json:"valid"` // Valid is true if CoreCurrencyCode is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCoreCurrencyCode) Scan(value interface{}) error {
	if value == nil {
		ns.CoreCurrencyCode, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CoreCurrencyCode.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCoreCurrencyCode) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CoreCurrencyCode), nil
}

type CoreTransactionStatus string

const (
	CoreTransactionStatusPending   CoreTransactionStatus = "pending"
	CoreTransactionStatusCompleted CoreTransactionStatus = "completed"
	CoreTransactionStatusFailed    CoreTransactionStatus = "failed"
	CoreTransactionStatusCancelled CoreTransactionStatus = "cancelled"
)

func (e *CoreTransactionStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CoreTransactionStatus(s)
	case string:
		*e = CoreTransactionStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for CoreTransactionStatus: %T", src)
	}
	return nil
}

type NullCoreTransactionStatus struct {
	CoreTransactionStatus CoreTransactionStatus `json:"core_transaction_status"`
	Valid                 bool                  `json:"valid"` // Valid is true if CoreTransactionStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCoreTransactionStatus) Scan(value interface{}) error {
	if value == nil {
		ns.CoreTransactionStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CoreTransactionStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCoreTransactionStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CoreTransactionStatus), nil
}

type CoreTransactionType string

const (
	CoreTransactionTypeDebit  CoreTransactionType = "debit"
	CoreTransactionTypeCredit CoreTransactionType = "credit"
)

func (e *CoreTransactionType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CoreTransactionType(s)
	case string:
		*e = CoreTransactionType(s)
	default:
		return fmt.Errorf("unsupported scan type for CoreTransactionType: %T", src)
	}
	return nil
}

type NullCoreTransactionType struct {
	CoreTransactionType CoreTransactionType `json:"core_transaction_type"`
	Valid               bool                `json:"valid"` // Valid is true if CoreTransactionType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCoreTransactionType) Scan(value interface{}) error {
	if value == nil {
		ns.CoreTransactionType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CoreTransactionType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCoreTransactionType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CoreTransactionType), nil
}

type CoreTransferStatus string

const (
	CoreTransferStatusPending    CoreTransferStatus = "pending"
	CoreTransferStatusProcessing CoreTransferStatus = "processing"
	CoreTransferStatusCompleted  CoreTransferStatus = "completed"
	CoreTransferStatusFailed     CoreTransferStatus = "failed"
	CoreTransferStatusCancelled  CoreTransferStatus = "cancelled"
)

func (e *CoreTransferStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CoreTransferStatus(s)
	case string:
		*e = CoreTransferStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for CoreTransferStatus: %T", src)
	}
	return nil
}

type NullCoreTransferStatus struct {
	CoreTransferStatus CoreTransferStatus `json:"core_transfer_status"`
	Valid              bool               `json:"valid"` // Valid is true if CoreTransferStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCoreTransferStatus) Scan(value interface{}) error {
	if value == nil {
		ns.CoreTransferStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CoreTransferStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCoreTransferStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CoreTransferStatus), nil
}

// Account information and balances
type CoreAccount struct {
	ID            pgtype.UUID `json:"id"`
	AccountNumber string      `json:"account_number"`
	AccountName   string      `json:"account_name"`
	// Current account balance with 4 decimal precision
	Balance   pgtype.Numeric     `json:"balance"`
	Currency  CoreCurrencyCode   `json:"currency"`
	Status    CoreAccountStatus  `json:"status"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	// Version for optimistic locking
	Version int32 `json:"version"`
}

// Audit trail for all balance changes
type CoreAccountBalanceHistory struct {
	ID            pgtype.UUID        `json:"id"`
	AccountID     pgtype.UUID        `json:"account_id"`
	TransactionID pgtype.UUID        `json:"transaction_id"`
	OldBalance    pgtype.Numeric     `json:"old_balance"`
	NewBalance    pgtype.Numeric     `json:"new_balance"`
	BalanceChange pgtype.Numeric     `json:"balance_change"`
	Operation     string             `json:"operation"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	CreatedBy     pgtype.Text        `json:"created_by"`
}

// Audit trail for compensation operations in Temporal workflows
type CoreCompensationAuditTrail struct {
	ID pgtype.UUID `json:"id"`
	// Temporal workflow ID for compensation tracking
	WorkflowID                string                 `json:"workflow_id"`
	RunID                     string                 `json:"run_id"`
	TransferID                pgtype.Text            `json:"transfer_id"`
	OriginalTransactionID     pgtype.UUID            `json:"original_transaction_id"`
	CompensationTransactionID pgtype.UUID            `json:"compensation_transaction_id"`
	CompensationReason        string                 `json:"compensation_reason"`
	CompensationType          CoreCompensationType   `json:"compensation_type"`
	CompensationStatus        CoreCompensationStatus `json:"compensation_status"`
	// Number of attempts made for this compensation
	CompensationAttempts int32              `json:"compensation_attempts"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	CompletedAt          pgtype.Timestamptz `json:"completed_at"`
	FailureReason        pgtype.Text        `json:"failure_reason"`
	// Timeout duration if compensation timed out
	TimeoutDurationMs pgtype.Int4 `json:"timeout_duration_ms"`
	Metadata          []byte      `json:"metadata"`
}

// Individual debit/credit transactions
type CoreTransaction struct {
	ID              pgtype.UUID           `json:"id"`
	AccountID       pgtype.UUID           `json:"account_id"`
	TransactionType CoreTransactionType   `json:"transaction_type"`
	Amount          pgtype.Numeric        `json:"amount"`
	Currency        CoreCurrencyCode      `json:"currency"`
	Description     pgtype.Text           `json:"description"`
	ReferenceID     pgtype.Text           `json:"reference_id"`
	Status          CoreTransactionStatus `json:"status"`
	// Ensures idempotent transaction processing
	IdempotencyKey pgtype.Text        `json:"idempotency_key"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	CompletedAt    pgtype.Timestamptz `json:"completed_at"`
	// Additional transaction context and data
	Metadata []byte `json:"metadata"`
}

// Complete money transfer operations
type CoreTransfer struct {
	ID                  pgtype.UUID        `json:"id"`
	TransferID          string             `json:"transfer_id"`
	FromAccountID       pgtype.UUID        `json:"from_account_id"`
	ToAccountID         pgtype.UUID        `json:"to_account_id"`
	Amount              pgtype.Numeric     `json:"amount"`
	Currency            CoreCurrencyCode   `json:"currency"`
	Description         pgtype.Text        `json:"description"`
	Status              CoreTransferStatus `json:"status"`
	DebitTransactionID  pgtype.UUID        `json:"debit_transaction_id"`
	CreditTransactionID pgtype.UUID        `json:"credit_transaction_id"`
	// Temporal workflow ID for tracking
	WorkflowID pgtype.Text `json:"workflow_id"`
	// Temporal run ID for tracking
	RunID         pgtype.Text        `json:"run_id"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	CompletedAt   pgtype.Timestamptz `json:"completed_at"`
	FailedAt      pgtype.Timestamptz `json:"failed_at"`
	FailureReason pgtype.Text        `json:"failure_reason"`
	Metadata      []byte             `json:"metadata"`
}
