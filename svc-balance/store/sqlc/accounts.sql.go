// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: accounts.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkAccountBalance = `-- name: CheckAccountBalance :one
SELECT 
    id,
    account_number,
    account_name,
    balance,
    currency,
    status,
    CASE 
        WHEN $2::decimal IS NULL THEN true
        WHEN balance >= $2::decimal THEN true
        ELSE false
    END AS sufficient_funds
FROM core.accounts
WHERE id = $1
`

type CheckAccountBalanceParams struct {
	ID      pgtype.UUID    `json:"id"`
	Column2 pgtype.Numeric `json:"column_2"`
}

type CheckAccountBalanceRow struct {
	ID              pgtype.UUID       `json:"id"`
	AccountNumber   string            `json:"account_number"`
	AccountName     string            `json:"account_name"`
	Balance         pgtype.Numeric    `json:"balance"`
	Currency        CoreCurrencyCode  `json:"currency"`
	Status          CoreAccountStatus `json:"status"`
	SufficientFunds bool              `json:"sufficient_funds"`
}

func (q *Queries) CheckAccountBalance(ctx context.Context, arg CheckAccountBalanceParams) (CheckAccountBalanceRow, error) {
	row := q.db.QueryRow(ctx, checkAccountBalance, arg.ID, arg.Column2)
	var i CheckAccountBalanceRow
	err := row.Scan(
		&i.ID,
		&i.AccountNumber,
		&i.AccountName,
		&i.Balance,
		&i.Currency,
		&i.Status,
		&i.SufficientFunds,
	)
	return i, err
}

const getAccountBalanceHistory = `-- name: GetAccountBalanceHistory :many
SELECT 
    h.id,
    h.account_id,
    h.transaction_id,
    h.old_balance,
    h.new_balance,
    h.balance_change,
    h.operation,
    h.created_at,
    h.created_by
FROM core.account_balance_history h
WHERE h.account_id = $1
ORDER BY h.created_at DESC
LIMIT $2 OFFSET $3
`

type GetAccountBalanceHistoryParams struct {
	AccountID pgtype.UUID `json:"account_id"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

func (q *Queries) GetAccountBalanceHistory(ctx context.Context, arg GetAccountBalanceHistoryParams) ([]CoreAccountBalanceHistory, error) {
	rows, err := q.db.Query(ctx, getAccountBalanceHistory, arg.AccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CoreAccountBalanceHistory{}
	for rows.Next() {
		var i CoreAccountBalanceHistory
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.TransactionID,
			&i.OldBalance,
			&i.NewBalance,
			&i.BalanceChange,
			&i.Operation,
			&i.CreatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccountByID = `-- name: GetAccountByID :one
SELECT 
    id,
    account_number,
    account_name,
    balance,
    currency,
    status,
    created_at,
    updated_at,
    version
FROM core.accounts
WHERE id = $1
`

func (q *Queries) GetAccountByID(ctx context.Context, id pgtype.UUID) (CoreAccount, error) {
	row := q.db.QueryRow(ctx, getAccountByID, id)
	var i CoreAccount
	err := row.Scan(
		&i.ID,
		&i.AccountNumber,
		&i.AccountName,
		&i.Balance,
		&i.Currency,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
	)
	return i, err
}

const getAccountByNumber = `-- name: GetAccountByNumber :one
SELECT 
    id,
    account_number,
    account_name,
    balance,
    currency,
    status,
    created_at,
    updated_at,
    version
FROM core.accounts
WHERE account_number = $1
`

func (q *Queries) GetAccountByNumber(ctx context.Context, accountNumber string) (CoreAccount, error) {
	row := q.db.QueryRow(ctx, getAccountByNumber, accountNumber)
	var i CoreAccount
	err := row.Scan(
		&i.ID,
		&i.AccountNumber,
		&i.AccountName,
		&i.Balance,
		&i.Currency,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
	)
	return i, err
}

const getAccountSummary = `-- name: GetAccountSummary :one
SELECT 
    a.id,
    a.account_number,
    a.account_name,
    a.balance,
    a.currency,
    a.status,
    a.created_at,
    a.updated_at,
    COUNT(t.id) AS transaction_count,
    COALESCE(SUM(CASE WHEN t.transaction_type = 'debit' THEN t.amount ELSE 0 END), 0) AS total_debits,
    COALESCE(SUM(CASE WHEN t.transaction_type = 'credit' THEN t.amount ELSE 0 END), 0) AS total_credits
FROM core.accounts a
LEFT JOIN core.transactions t ON a.id = t.account_id AND t.status = 'completed'
WHERE a.id = $1
GROUP BY a.id, a.account_number, a.account_name, a.balance, a.currency, a.status, a.created_at, a.updated_at
`

type GetAccountSummaryRow struct {
	ID               pgtype.UUID        `json:"id"`
	AccountNumber    string             `json:"account_number"`
	AccountName      string             `json:"account_name"`
	Balance          pgtype.Numeric     `json:"balance"`
	Currency         CoreCurrencyCode   `json:"currency"`
	Status           CoreAccountStatus  `json:"status"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	TransactionCount int64              `json:"transaction_count"`
	TotalDebits      interface{}        `json:"total_debits"`
	TotalCredits     interface{}        `json:"total_credits"`
}

func (q *Queries) GetAccountSummary(ctx context.Context, id pgtype.UUID) (GetAccountSummaryRow, error) {
	row := q.db.QueryRow(ctx, getAccountSummary, id)
	var i GetAccountSummaryRow
	err := row.Scan(
		&i.ID,
		&i.AccountNumber,
		&i.AccountName,
		&i.Balance,
		&i.Currency,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TransactionCount,
		&i.TotalDebits,
		&i.TotalCredits,
	)
	return i, err
}

const getAccountsByBalanceRange = `-- name: GetAccountsByBalanceRange :many
SELECT 
    id,
    account_number,
    account_name,
    balance,
    currency,
    status,
    created_at,
    updated_at
FROM core.accounts
WHERE balance BETWEEN $1 AND $2
ORDER BY balance DESC
LIMIT $3 OFFSET $4
`

type GetAccountsByBalanceRangeParams struct {
	Balance   pgtype.Numeric `json:"balance"`
	Balance_2 pgtype.Numeric `json:"balance_2"`
	Limit     int32          `json:"limit"`
	Offset    int32          `json:"offset"`
}

type GetAccountsByBalanceRangeRow struct {
	ID            pgtype.UUID        `json:"id"`
	AccountNumber string             `json:"account_number"`
	AccountName   string             `json:"account_name"`
	Balance       pgtype.Numeric     `json:"balance"`
	Currency      CoreCurrencyCode   `json:"currency"`
	Status        CoreAccountStatus  `json:"status"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetAccountsByBalanceRange(ctx context.Context, arg GetAccountsByBalanceRangeParams) ([]GetAccountsByBalanceRangeRow, error) {
	rows, err := q.db.Query(ctx, getAccountsByBalanceRange,
		arg.Balance,
		arg.Balance_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAccountsByBalanceRangeRow{}
	for rows.Next() {
		var i GetAccountsByBalanceRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountNumber,
			&i.AccountName,
			&i.Balance,
			&i.Currency,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccountsByCurrency = `-- name: GetAccountsByCurrency :many
SELECT 
    id,
    account_number,
    account_name,
    balance,
    currency,
    status,
    created_at,
    updated_at,
    version
FROM core.accounts
WHERE currency = $1
ORDER BY balance DESC
LIMIT $2 OFFSET $3
`

type GetAccountsByCurrencyParams struct {
	Currency CoreCurrencyCode `json:"currency"`
	Limit    int32            `json:"limit"`
	Offset   int32            `json:"offset"`
}

func (q *Queries) GetAccountsByCurrency(ctx context.Context, arg GetAccountsByCurrencyParams) ([]CoreAccount, error) {
	rows, err := q.db.Query(ctx, getAccountsByCurrency, arg.Currency, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CoreAccount{}
	for rows.Next() {
		var i CoreAccount
		if err := rows.Scan(
			&i.ID,
			&i.AccountNumber,
			&i.AccountName,
			&i.Balance,
			&i.Currency,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccountsByStatus = `-- name: GetAccountsByStatus :many
SELECT 
    id,
    account_number,
    account_name,
    balance,
    currency,
    status,
    created_at,
    updated_at,
    version
FROM core.accounts
WHERE status = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetAccountsByStatusParams struct {
	Status CoreAccountStatus `json:"status"`
	Limit  int32             `json:"limit"`
	Offset int32             `json:"offset"`
}

func (q *Queries) GetAccountsByStatus(ctx context.Context, arg GetAccountsByStatusParams) ([]CoreAccount, error) {
	rows, err := q.db.Query(ctx, getAccountsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CoreAccount{}
	for rows.Next() {
		var i CoreAccount
		if err := rows.Scan(
			&i.ID,
			&i.AccountNumber,
			&i.AccountName,
			&i.Balance,
			&i.Currency,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccountsWithLowBalance = `-- name: GetAccountsWithLowBalance :many
SELECT 
    id,
    account_number,
    account_name,
    balance,
    currency,
    status,
    created_at,
    updated_at
FROM core.accounts
WHERE balance < $1 AND status = 'active'
ORDER BY balance ASC
LIMIT $2 OFFSET $3
`

type GetAccountsWithLowBalanceParams struct {
	Balance pgtype.Numeric `json:"balance"`
	Limit   int32          `json:"limit"`
	Offset  int32          `json:"offset"`
}

type GetAccountsWithLowBalanceRow struct {
	ID            pgtype.UUID        `json:"id"`
	AccountNumber string             `json:"account_number"`
	AccountName   string             `json:"account_name"`
	Balance       pgtype.Numeric     `json:"balance"`
	Currency      CoreCurrencyCode   `json:"currency"`
	Status        CoreAccountStatus  `json:"status"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetAccountsWithLowBalance(ctx context.Context, arg GetAccountsWithLowBalanceParams) ([]GetAccountsWithLowBalanceRow, error) {
	rows, err := q.db.Query(ctx, getAccountsWithLowBalance, arg.Balance, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAccountsWithLowBalanceRow{}
	for rows.Next() {
		var i GetAccountsWithLowBalanceRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountNumber,
			&i.AccountName,
			&i.Balance,
			&i.Currency,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const validateAccountForTransaction = `-- name: ValidateAccountForTransaction :one
SELECT 
    id,
    account_number,
    account_name,
    balance,
    currency,
    status,
    CASE 
        WHEN status != 'active' THEN false
        WHEN $2::text = 'debit' AND balance < $3::decimal THEN false
        ELSE true
    END AS can_transact,
    CASE 
        WHEN status != 'active' THEN 'Account is not active'
        WHEN $2::text = 'debit' AND balance < $3::decimal THEN 'Insufficient funds'
        ELSE 'OK'
    END AS validation_message
FROM core.accounts
WHERE id = $1
`

type ValidateAccountForTransactionParams struct {
	ID      pgtype.UUID    `json:"id"`
	Column2 string         `json:"column_2"`
	Column3 pgtype.Numeric `json:"column_3"`
}

type ValidateAccountForTransactionRow struct {
	ID                pgtype.UUID       `json:"id"`
	AccountNumber     string            `json:"account_number"`
	AccountName       string            `json:"account_name"`
	Balance           pgtype.Numeric    `json:"balance"`
	Currency          CoreCurrencyCode  `json:"currency"`
	Status            CoreAccountStatus `json:"status"`
	CanTransact       bool              `json:"can_transact"`
	ValidationMessage string            `json:"validation_message"`
}

func (q *Queries) ValidateAccountForTransaction(ctx context.Context, arg ValidateAccountForTransactionParams) (ValidateAccountForTransactionRow, error) {
	row := q.db.QueryRow(ctx, validateAccountForTransaction, arg.ID, arg.Column2, arg.Column3)
	var i ValidateAccountForTransactionRow
	err := row.Scan(
		&i.ID,
		&i.AccountNumber,
		&i.AccountName,
		&i.Balance,
		&i.Currency,
		&i.Status,
		&i.CanTransact,
		&i.ValidationMessage,
	)
	return i, err
}
